Tutorial:
We can solve this problem greedily. Let's choose the first element equal to ğ‘™
. Then, the second element should be ğ‘™+1
. The third ğ‘™+3
, and so on. In general, the ğ‘–âˆ’
th element is equal to ğ‘™+ğ‘–â‹…(ğ‘–+1)2.

Proof of this solution:

Assume that array ğ‘
 is the array made by our algorithm and ğ‘
 is the array with a better answer. This means that ğ‘™ğ‘’ğ‘›(ğ‘)>ğ‘™ğ‘’ğ‘›(ğ‘)
. By the construction of ğ‘
, there exists an integer ğ‘–
 such that for all ğ‘—<ğ‘–
, ğ‘ğ‘—=ğ‘ğ‘—
 and ğ‘ğ‘–<ğ‘ğ‘–
, because ğ‘ğ‘–
 we choose as the smallest possible element. WLOG assume that ğ‘™ğ‘’ğ‘›(ğ‘)=ğ‘™ğ‘’ğ‘›(ğ‘)+1=ğ‘›
. Then ğ‘ğ‘›âˆ’ğ‘ğ‘›âˆ’1>ğ‘ğ‘›âˆ’1âˆ’ğ‘ğ‘›âˆ’2â‰¥ğ‘ğ‘›âˆ’1âˆ’ğ‘ğ‘›âˆ’2
. So, we can append ğ‘ğ‘›
 to the array ğ‘
, which leads to a contradiction.

Now, the task is to find the biggest ğ‘¥
 such that ğ‘™+ğ‘¥â‹…(ğ‘¥+1)2â‰¤ğ‘Ÿ
. In fact, it can be found by binary search, the formula of discriminant, or just by brute force.

C++ Code:
#include <bits/stdc++.h>

using namespace std;

int main(){
    int t;
    cin>>t;
    while(t--)
    {
        long long a,b;
        cin>>a>>b;
        b-=a;
        long long l=2,r=1000000000;
        while(l<r)
        {
            long long m=(l+r)/2;
            if(m*(m-1)/2<=b)
            {
                l=m+1;
            }
            else
            {
                r=m;
            }
        }
        cout<<l-1<<endl;
    }
}