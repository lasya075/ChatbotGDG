Tutorial:
Let's fix one ğ‘¥ and try to solve this task for it. As we know, in 0âˆ’ indexed array median is âŒŠğ‘›2âŒ‹ where ğ‘› is number of elements in the array, so to find median, we need to find the smallest element which has at least âŒŠğ‘›2âŒ‹
elements in the array that is less or equal to it. Also, it is obvious, that we need to decrease all elements till we can, since the least element, the least median of the array is. So, after all operation, we change ğ‘ğ‘– to ğ‘ğ‘–modğ‘¥.

How to find number of ğ‘– that ğ‘ğ‘–modğ‘¥â‰¤ğ‘š for some ğ‘š. In fact, we can try to find number of elements in range [ğ‘˜â‹…ğ‘¥,ğ‘˜â‹…ğ‘¥+ğ‘š] for all ğ‘˜,
since all this elements will be less then ğ‘š if we take it by modulo ğ‘¥. To find number of elements in such range, we can notice that ğ‘ğ‘–â‰¤ğ‘›,
so we can make prefix sum of counting array (let's call it ğ‘ğ‘Ÿğ‘’ğ‘“[ğ‘–] number of elements less or equal ğ‘–) and then number of elements in tange [ğ‘,ğ‘] will be ğ‘ğ‘Ÿğ‘’ğ‘“[ğ‘]âˆ’ğ‘ğ‘Ÿğ‘’ğ‘“[ğ‘âˆ’1].
Also, since ğ‘ğ‘–â‰¤ğ‘›, ğ‘˜ will be less then ğ‘›ğ‘¥, so for fixed ğ‘¥ our solution will work in ğ‘›ğ‘¥â‹…ğ‘™ğ‘œğ‘”(ğ‘›). Let's precompute it for all ğ‘¥ in range [1,ğ‘›]. Then, it will work in time âˆ‘ğ‘›+1ğ‘¥=1ğ‘›ğ‘¥â‹…ğ‘™ğ‘œğ‘”(ğ‘›)=ğ‘™ğ‘œğ‘”(ğ‘›)â‹…âˆ‘ğ‘›+1ğ‘¥=1ğ‘›ğ‘¥=(âˆ—)ğ‘™ğ‘œğ‘”(ğ‘›)â‹…ğ‘›â‹…ğ‘™ğ‘œğ‘”(ğ‘›)=ğ‘›â‹…ğ‘™ğ‘œğ‘”2(ğ‘›).

(âˆ—)This transition is true because of âˆ‘ğ‘›+1ğ‘–=1ğ‘›ğ‘¥ is harmonic series. It means, âˆ‘ğ‘›+1ğ‘–=1ğ‘›ğ‘¥=ğ‘›â‹…âˆ‘ğ‘›+1ğ‘–=11ğ‘¥â‰¤ğ‘›â‹…ğ‘™ğ‘œğ‘”(ğ‘›).

C++ Code:
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int t=1;
    cin>>t;
    for(int i=1;i<=t;i++)
    {
        int n,m;
        cin>>n>>m;
        vector<int>a(n);
        vector<int>c(n+1,0ll);
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
            c[a[i]]++;
        }
        for(int i=1;i<=n;i++)
        {
            c[i]+=c[i-1];
        }
        int res[n+1]={0};
        for(int x=1;x<=n;x++)
        {
            int l=0,r=x;
            while(l<r)
            {
                int mid=(l+r)/2;
                int cnt=c[mid];
                for(int k=1;k*x<=n;k++)
                {
                    cnt+=c[min(k*x+mid,n)]-c[k*x-1];
                }
                if(cnt-1>=n/2)
                {
                    r=mid;
                }
                else
                {
                    l=mid+1;
                }
            }
            res[x]=l;
        }
        while(m--)
        {
            int x;
            cin>>x;
            cout<<res[x]<<" ";
        }
        cout<<endl;
    }
}
