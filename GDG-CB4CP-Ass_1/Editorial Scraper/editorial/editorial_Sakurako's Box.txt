Tutorial:
By the statement, we need to find the value of this expresion âˆ‘ğ‘›ğ‘–=0âˆ‘ğ‘›ğ‘—=ğ‘–+1ğ‘ğ‘–â‹…ğ‘ğ‘—ğ‘›â‹…(ğ‘›âˆ’1)2
. Let's find this two values separately. For the first, we can do it in several ways. We can see that this sum equal to âˆ‘ğ‘›ğ‘–=0ğ‘ğ‘–â‹…(âˆ‘ğ‘›ğ‘—=ğ‘–+1ğ‘ğ‘—)
 and compute by prefix sum. Also, we can notice that it is equal to (âˆ‘ğ‘›ğ‘–=0ğ‘ğ‘–)2âˆ’âˆ‘ğ‘›ğ‘–=0ğ‘2ğ‘–2
. Note, that for second approach you need to use division by modulo, i.e. 2âˆ’1=2ğ‘âˆ’2
 for prime p. To compute ğ‘›â‹…(ğ‘›âˆ’1)2
, you can compute ğ‘›â‹…(ğ‘›âˆ’1)
 by modulo and than use division by modulo for 2âˆ’1
. Then, also using division by modulo you need to divide first value by second.

C++ Code:
#include <bits/stdc++.h>

using namespace std;
constexpr int mod=1e9+7;

long long binpow(long long a,long long b)
{
    if(b==0)
    {
        return 1;
    }
    if(b%2)
    {
        return (a*binpow(a,b-1))%mod;
    }
    return binpow((a*a)%mod,b/2);
}

int main(){
    int t;
    cin>>t;
    while(t--)
    {
        long long n;
        cin>>n;
        long long a[n],sum=0,sumsq=0;
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
            sum+=a[i];sum%=mod;
            sumsq+=a[i]*a[i];
            sumsq%=mod;
        }
        sum*=sum;sum%=mod;
        sum=(sum-sumsq+mod)%mod;
        sum=(sum*binpow(2,mod-2))%mod;
        long long cnt=n*(n-1)/2;cnt%=mod;
        cout<<(sum%mod)*binpow(cnt,mod-2)%mod<<endl;
    }
}